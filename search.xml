<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/12/21/sgm-xi-lie-suan-fa-zong-jie/"/>
      <url>/2024/12/21/sgm-xi-lie-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="SGM系列算法总结"><a href="#SGM系列算法总结" class="headerlink" title="SGM系列算法总结"></a>SGM系列算法总结</h1><h1 id="一、SGM"><a href="#一、SGM" class="headerlink" title="一、SGM"></a>一、SGM</h1><h2 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h2><h3 id="1-相似度计算"><a href="#1-相似度计算" class="headerlink" title="1.相似度计算"></a>1.相似度计算</h3><p>Census变换：利用相对灰度关系将像素进行二进制编码</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407170939834.jpeg"></p><p>在进行相似度匹配时，直接计算二进制编码的汉明距离即可。</p><p>Census变换对整体的明暗变化并不敏感，因为是比较的相对灰度关系，所以即使左右影像亮度不一致，也能得到较好的匹配效果，同时具有并行度高的优点。</p><h3 id="2-代价聚合"><a href="#2-代价聚合" class="headerlink" title="2.代价聚合"></a>2.代价聚合</h3><p>代价计算结果无法直接应用为视差&#x2F;深度，存在许多噪声。使用代价聚合步骤优化各个像素的结果并增强像素间代价值的相关性。</p><p>SGM构建全局能量函数，寻找每个像素的最优视差&#x2F;深度使整张图的全局能量函数最小。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407170948633.png"></p><p>其中，$E_{data}$为数据项，是反应视差图对应的总体匹配代价的测度；$E_{smooth}$是平滑项，为了让视差图满足某些条件假设的约束，如场景表面的连续性假设，平滑项会对相邻像素视差变化超过一定像素的情况进行惩罚（惩罚一般就是加大能量值）。</p><p>SGM的能量函数表达式为：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407170954183.png"></p><p>其中，公式的第一项是数据项，表示当视差图为$D$时，所有像素的匹配代价的累加，第二项和第三项是平滑项，表示利用像素$p$的$N_p$邻域内的所有像素$q$对$p$进行惩罚，其中第二项惩罚力度较小($P_{1}$较小)，对相邻像素视差变化很小的情况(等于1个像素)进行惩罚；第三项惩罚力度较大($P_2&gt; P_1$)，对相邻像素视差变化很大(大于1个像素)的情况进行惩罚。较小的惩罚项可以让算法能够适应视差变化小的情形，如倾斜的平面或者连续的曲面，较大的惩罚项可以让算法正确处理视差非连续情况，由于影像的亮度边缘位置（也就是梯度较大的位置）是前景背景交界的可能性较大，这些位置的像素邻域内往往不是视差连续的，相差较大，为了保护真实场景中的视差非连续情况，$P_2$往往是根据相邻像素的灰度差来动态调整，如公式3所示：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407171758290.png"></p><p>$P_2^′$为$P_2$的初始值，一般设置为远大于$P_1$。这个公式的含义是：如果像素和它的邻域像素亮度差很大，那么该像素很可能是位于视差非连续区域，则一定程度上允许其和邻域像素的视差差值超过1个像素，对于超过1个像素的惩罚力度就适当减小一点。</p><p>实际上，SGM能量函数最优化问题依旧是一个NP完全问题，为高效的解决它，SGM提出一种<strong>路径代价聚合</strong>的思路。</p><p>像素$p$沿某条路径$r$进行代价计算公式$L_r$：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407171813291.png"></p><p>像素$p$在视差$d$下的cost值$C(p,d)$，<strong>加上</strong>min{$r$路径下$p$的上一个像素$p-r$在视差$d$下的cost值、$r$路径下$p$的上一个像素$p-r$在视差$d-1$下的cost值+$P_1$、$r$路径下$p$的上一个像素$p-r$在视差$d+1$下的cost值+$P_1$、min( $r$路径下$p$的上一个像素$p-r$在任意视差下的cost值 ) +$P_2$ }，<strong>减去</strong>$r$路径下$p$的上一个像素$p-r$在任意视差下的cost值</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407180957822.png"></p><p>第三项是为了保证路径代价$L_r$不超过一定上限：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181002333.png" alt="image-20240718100200318"></p><p>总路径代价S为：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181002944.png" alt="image-20240718100232930"></p><p>多路径聚合：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181003862.png" alt="image-20240718100311840"></p><p>根据路径数不同，聚合的方向也有所不同，一般来说，有4路径（红色箭头方向）、8路径（红色+黑色箭头方向）和16路径（白色箭头方向）三种聚合方式，路径数越多效果越好，但是耗时也会越长，往往需要平衡利弊，根据应用的实际要求来选择合适的路径数。</p><p>路径数不超过16可以很容易推导出$S≤16(C_{max}+P_2)$，这个不等式很重要，它表明选择合适的$P_2$值可以将聚合代价值$S$控制在一定数值范围内，减少聚合代价数组对内存的占用。如采用基于5×5窗口的Census变换的方法计算得到的匹配代价值$C$最高不超过25（因为Census变换后的比特串最大有效长度为25），则匹配代价只需用一个字节来存储，而当$P_2 ≤ 65535&#x2F;16-25$时，$S$可以只用两个字节来存储，因为存储代价的$C$和$S$空间大小是$W×H×D$，当影像尺寸较大时，对内存的占用是巨大的，所以减少元素存储所需要的字节数是必要的。</p><h3 id="3-视差计算"><a href="#3-视差计算" class="headerlink" title="3.视差计算"></a>3.视差计算</h3><p>WTA：在一系列的视差代价中寻找最小代价值对应的位置视差，使用二次曲线函数进行插值得到亚像素精度的视差值</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181017471.png" alt="image-20240718101727431"></p><p><strong>基础知识</strong>：</p><p>1.由连续到离散导数求解：</p><p>对函数$f(x)$进行泰勒级数展开得到：</p><p>$f(x) &#x3D; f(x_0) + f^{‘}(x_0)(x-x_0)+\frac{1}{2}f^{‘’}(x_0)(x-x_0)^2+O(\Delta x^3)$</p><p>其在$x&#x3D;x_0$处的导数为(前向微分$x_0+\Delta x$—忽略二阶项)：</p><p>$f^{‘}(x_0) &#x3D; \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}+O(\Delta x)$</p><p>离散化后即$\Delta x&#x3D;x_{n+1}-x_n \ \ \ pixel$，$f^{‘}(x_n) &#x3D; \frac{y_{n+1} - y_n}{x_{n+1}-x_n}+O(\Delta x)$</p><p>误差为$O(\Delta x)$，比较大，但是引入二阶会使得离散方程复杂化。可以使用后向微分进行<strong>差分</strong>处理，来增强离散化导数的精度。</p><p>其在$x&#x3D;x_0$处的导数为(后向微分$x_0-\Delta x$—忽略二阶项)：</p><p>$f^{‘}(x_0) &#x3D; \frac{f(x_0)-f(x_0-\Delta x)}{\Delta x}+O(\Delta x)$</p><p>将前向微分和后向微分结果相加，即得：</p><p>$f^{‘}(x_0) &#x3D; \frac{f(x_0+\Delta x)-f(x_0-\Delta x)}{2\Delta x}+O(\Delta x^2)$</p><p>因为两者相加时，将二阶消去了，所以精度提高(不进行移项，保留二阶项进行验算即可)</p><p>在离散函数中体现为：</p><p>$f^{‘}(x_n) &#x3D; \frac{y_{n+1} - y_{n-1}}{x_{n+1}-x_{n-1}}+O(\Delta x^2)$</p><p><strong>所以求解某像素梯度时，通常取两边的像素值进行处理</strong></p><p>2.泰勒展开式求极值</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041831100.png"></p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041831912.png" alt="image-20240804183128887"></p><p>$d &#x3D; d_0 + \Delta x$</p><h3 id="4-视差优化"><a href="#4-视差优化" class="headerlink" title="4.视差优化"></a>4.视差优化</h3><p>剔除错误视差，提高视差精度</p><h4 id="4-1一致性检查"><a href="#4-1一致性检查" class="headerlink" title="4.1一致性检查"></a>4.1一致性检查</h4><p>把左右影像位置对调，再计算一个右影像视差图，对照两个视差图来看同名点对是否能够相互匹配成功。<br>对调前，左影像像素$a$匹配右影像像素$b$；则对调后，$b$也匹配$a$为一致，否则为不一致（比如对调后$b$匹配$c$）。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181733390.png" alt="image-20240718173259502"></p><p>一致性检查的一般性操作步骤：</p><ol><li>获取左右视差图。</li><li>对左视差图的每个像素$a$，计算出同名点在右视差图中的像素位置$b$。</li><li>判断$a$和$b$的视差值之差的绝对值是否小于一个阈值（通常为1个像素），如果超过阈值，则一致性检查不通过，把对应位置的视差变为无效值。</li></ol><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181731994.png" alt="image-20240718173147924"></p><p>表达公式如下：</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181733694.png" alt="image-20240718173353676"></p><p>$b$是左视图，$m$是右视图，$p$和$q$为同名点对。通常使用视差图对应$p-d$位置就为同名点$q$</p><p>一致性检查有内部型和外部型两种：</p><p><strong>内部型：</strong>直接通过左影像的代价数组，来推算右影像的代价数组，从而计算右影像的视差图。<br>右影像$(i,j)$视差为$d$的代价 &#x3D; 左影像$(i,j+d)$视差为$d$的代价<br>对于右影像的像素$(i,j)$，根据视差值$d$可算出左影像的对应像素位置为$(i,j+d)$，然后把左影像$(i,j+d)$同样视差值$d$下的代价值取出来赋给$(i,j,d)$。<br>根据此，我们可以将右影像每个像素的所有候选视差$d$的代价值$Cost(i,j,d)$都得到，进而寻找最小代价值对应的视差，得到右影像视差图。</p><p><strong>外部型：</strong>就是在算法输入时把左右图像数据对调，再执行一次完整的立体匹配，得到右影像视差图。<br>这里需要注意的是，左右对调后，视差意义上和左影像是相反的，而立体匹配算法的设定是：视差&#x3D;左减右，如果只做对调（就是简单的把右影像数据作为左影像数据传进算法），是得不到正确结果的，因为对调后重叠区在两边，不符合算法的设定，所以这里一般会在对调后，把左右影像的像素来个水平镜像翻转，这样两张影像的重叠区到了中间，视差就等于左减右了。</p><blockquote><p>外部型检查需要执行两次完整的匹配流程，时间效率不如内部型检查。</p></blockquote><h4 id="4-2唯一性约束"><a href="#4-2唯一性约束" class="headerlink" title="4.2唯一性约束"></a>4.2唯一性约束</h4><p>唯一性约束：最优视差的代价值应该是所有候选视差中唯一的最小代价。如果有另外一个视差的代价值和它一样，那么它就不再是最好的那一个了，而是最好的两个之一，而我们不能接受有两个最好，只能忍痛舍弃它。</p><p>这里面蕴含的另一层含义是：视差估计的可靠性！如果两个最小的代价值相差很小，比如一个是30，一个是31，因为视差估计是带有噪声影响的，所以其实不能肯定的说是30最好还是31最好，可能31才是正确的那个视差，因为两个值相差太小了，可能是由于一些轻微的噪声导致实际上最优的视差的代价值却是次最小的。所以就干脆把这种让人头疼的选择题给PASS掉。</p><p><strong>计算最小代价和次最小代价的相对差值，如果差值小于阈值，那就表明最小的两个代价值相差不明显，就给这个像素赋一个无效视差。</strong></p><h4 id="4-3剔除小连通域"><a href="#4-3剔除小连通域" class="headerlink" title="4.3剔除小连通域"></a>4.3剔除小连通域</h4><p>连通域：通过4-邻域或8-邻域连通在一起的像素集合。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181754975.png" alt="image-20240718175440949"></p><p>这些像素是一致性检查的漏网之鱼，看上去和周围的像素极不协调，而且连通成一定大小的块，所以中值滤波这类窗口类滤波算法也搞不定，只能通过区域跟踪，把它们跟踪成块，然后判断块的大小是否小于一定的阈值，如果是则剔除，即把整块都置为无效视差。</p><h4 id="4-4滤波算法"><a href="#4-4滤波算法" class="headerlink" title="4.4滤波算法"></a>4.4滤波算法</h4><p>中值滤波作为一个平滑算法，主要是用来剔除视差图中的一些孤立的离群外点，同时还能起到填补小洞的作用。</p><h4 id="4-5视差填充"><a href="#4-5视差填充" class="headerlink" title="4.5视差填充"></a>4.5视差填充</h4><p>无效像素区域可以分为<strong>遮挡区</strong>和<strong>误匹配区</strong><br><strong>遮挡区</strong>：由于前景遮挡而在左视图上可见但在右视图上不可见的像素区域。<br><strong>误匹配区</strong>：位于非遮挡区域的错误匹配像素区域。</p><p>遮挡区位于视差非连续区域，一侧是前景，视差值较大，一侧是背景，视差值较小，它理应和背景像素视差更为接近，而和前景视差相差较大，所以填补时应该尽量选择周围背景像素的视差，避免选择前景像素。</p><p>误匹配区并不在遮挡区，邻域像素都位于一个连续的视差表面，视差是连续的，所以填补时可以考虑邻域内的所有像素。</p><p>通过如下方法判断<strong>遮挡区</strong>：</p><ol><li>像素$p$是通过各种优化操作而判定的无效像素。</li><li>左影像像素$p$在右影像上的匹配像素为$q&#x3D;p-d$，像素$q$在右视差图上的值为$d_r$ ，通过$d_r$找到左影像的匹配点$p’$，获取$p’$的视差$d’$，若$d’&gt;d$，则$p$为遮挡区。</li></ol><p>第二条换句话描述：假设$q$是$p$通过视差$d$找到的同名点，如果在左影像存在另外一个像素$p’$和$q$是同名点而且它的视差比$d$要大，那么$p$就是遮挡区。</p><blockquote><p>有人问，既然像素$p$是无效像素，那么为啥还有视差值呢，答案就是在给$p$无效值之前判断，这一步可以在一致性检查步骤里完成，实际上遮挡区主要都是通过一致性检查来使其无效的，因为遮挡区存在明显的左右差异性（左可见，右不可见），所以一致性检查大概率会让这些区域的像素无效。我们在一致性检查让$p$的视差值无效之前，判断$p$是否是遮挡区和误匹配区。</p></blockquote><p>判断无效像素区域后，如何根据两个区域进行不同的视差填充</p><p>首先，两者的共同点是，有效视差都来自于周围有效像素的视差值，区别在于如何从周围的有效视差中选出最合适的一个。</p><p>对于遮挡区像素，因为它的身份是背景像素，所以它是不能选择周围的前景像素视差值的，应该选择周围背景像素的视差值。由于背景像素视差值比前景像素小，所以在收集周围的有效视差值后，应选择较小的几个，SGM选择的是次最小视差。</p><p>对于误匹配像素，它并不位于遮挡区，所以周围的像素都是可见的，而且没有遮挡导致的视差非连续的情况，它就像一个连续的表面凸起的一小块噪声，这时周围的视差值都是等价的，没有哪个应选哪个不应选，这时取中值就很适合。</p><p>选取有效像素：以像素为中心，等角度往外发射8条射线，收集每条射线碰到的第一个有效像素</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407181835088.png" alt="image-20240718183536061"></p><h1 id="二、plane-sweep-cross-ratio"><a href="#二、plane-sweep-cross-ratio" class="headerlink" title="二、plane-sweep+cross-ratio"></a>二、plane-sweep+cross-ratio</h1><p>DETERMINING PLANE-SWEEP SAMPLING POINTS IN IMAGE SPACE USING THE CROSS-RATIO FOR IMAGE-BASED DEPTH ESTIMATION</p><p><a href="https://isprs-archives.copernicus.org/articles/XLII-2-W6/325/2017/isprs-archives-XLII-2-W6-325-2017.pdf">https://isprs-archives.copernicus.org/articles/XLII-2-W6/325/2017/isprs-archives-XLII-2-W6-325-2017.pdf</a></p><h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><p>利用plane-sweep对三维平面均匀采样再计算对应的单应矩阵对图像进行投影匹配SGM，直接估计深度图</p><p>利用焦比不变性对深度采样步长进行划分，离相机越近，步长应该越小</p><p>plane-sweep SGM</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407240932748.png" alt="img"></p><p>将三维空间按深度d进行采样，法线n设置为光心[0,0,1]，可以求解每一个单应矩阵，直接将ref和src利用单应矩阵进行投影匹配，来组成SGM的cost volume</p><p>焦比不变性</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407240932799.png" alt="img"></p><p>相机光心C在平面l_0上各点p的比例关系和l_1，l_2相同，且与夹角$\delta$有关</p><p> $$ CR(p_{1}, p_{2} , p_{3}, p_{4} )&#x3D;\frac{\Delta (p_{1},p_{3})\Delta(p_{2},p_{4})}{\Delta(p_{1},p_{4})\Delta(p_{2},p_{3})}&#x3D;CR(a,b,c,d)&#x3D;\frac{\sin(\delta(a,c))\sin(\delta(b,d))}{\sin(\delta(a,d))\sin(\delta(b,c))}$$</p><p>可以利用src视角下的ref，利用焦比不变性对ref深度采样进行划分</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202407240932561.png" alt="img"></p><p>$$CR(V_{e1},V_{x_{min}^{‘}},V_{x_i^{‘}},V_{x_{max}^{‘}})\ \ \qquad &#x3D; \frac{\sin(\delta(V_{e1},V_{x_i^{‘}}))\sin(\delta(V_{x_{min}^{‘}}V_{x_{max}^{‘}}))}{\sin(\delta(V_{e1},V_{x_{max}^{‘}}))\sin(\delta(V_{x_{min}^{‘}},V_{x_i^{‘}}))}  \  \ \qquad &#x3D; \frac{\Delta(C_{1},X_{i})\Delta(X_{min},X_{max})}{\Delta(C_{1},X_{max})\Delta(X_{min},X_i)}  \ \ \ \qquad &#x3D;CR(C_{1},X_{min},X_i,X_{max}) \\qquad &#x3D;CR(C_1,d_{min},d_i,d_{max})$$</p><p>$$CR(C_1,d_{min},d_i,d_{max})  \   \ \qquad&#x3D;\frac{d_i\cdot(d_{max}-d_{min})}{d_{max}\cdot(d_{i}-d_{min})} \  \ \ \qquad&#x3D;\frac{\sin(\delta(V_{e1},V_{x_i^{‘}}))\sin(\delta(V_{x_{min}^{‘}},V_{x_{max}^{‘}}))}{\sin(\delta(V_{e1},V_{x_{max}^{‘}}))\sin(\delta(V_{x_{min}^{‘}},V_{x_i^{‘}}))}$$</p><h1 id="三、SGBM"><a href="#三、SGBM" class="headerlink" title="三、SGBM"></a>三、SGBM</h1><p><a href="https://blog.csdn.net/jin739738709/article/details/124145268">https://blog.csdn.net/jin739738709/article/details/124145268</a></p><h2 id="算法核心-1"><a href="#算法核心-1" class="headerlink" title="算法核心"></a>算法核心</h2><p>SGM算法框架</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041620017.png" alt="image-20240804162002252"></p><p>SGBM算法框架</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041620167.png" alt="image-20240804162052137"></p><p>对比之后可以发现，SGBM和SGM区别的地方在于匹配代价计算部分：SGBM采用的是SAD-BT，而SGM采用的是MI。</p><p>MI是指互信息（MI，Mutual Information），一种全局的代价计算方法，耗时较多。</p><p>而OpenCV在实现SGBM的时候采用了BT代价，这是一种一维匹配代价，所以在应用中不仅是用x-sobel和原图gray生成加权融合的BT代价，而且采用SAD的思路，采用邻域求和的方法，计算SAD-BT，这样计算出来的代价就是局部块代价，每个像素点的匹配代价会包含周围局部区域的信息。</p><p>对比之后可以发现，其他步骤都是一致的，比如代价聚合cost aggregation，赢者通吃wta，亚像素插值subpixel interpolation等等。</p><p>本文仅介绍BT代价</p><h3 id="1-BT代价"><a href="#1-BT代价" class="headerlink" title="1.BT代价"></a>1.BT代价</h3><p>BT代价(xsobel和原始灰度gray)<br>BT代价是一维匹配代价。</p><p>对比AD，AD也是一维匹配代价：像素灰度差值的绝对值。</p><p>对比census，census是二维匹配代价（比如，census核函数尺寸为5*5，会包含到局部的区域信息）</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041633793.png" alt="image-20240804163331758"></p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041634752.png" alt="image-20240804163400719"></p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041634612.png" alt="image-20240804163440579"></p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041637941.png"></p><p>可以看出，</p><p>在序列比较平稳时，即相邻像素点的灰度值很接近时，两种方法的结果是相近的，</p><p>而当匹配序列起浮变化的时候（类似图像中的不连续区域），基于BT代价的不相似性依旧是接近于0，而AD则出现很大的波动。</p><p>由此可见，对于图片的不连续区域，利用BT代价计算法可以有效的进行准确匹配而不会产生过多的误差，证明该方法是可行且具有显著效果的。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041640948.png" alt="image-20240804164041915"></p><h3 id="2-X-Sobel"><a href="#2-X-Sobel" class="headerlink" title="2.X-Sobel"></a>2.X-Sobel</h3><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041645080.png" alt="image-20240804164557044"></p><h3 id="3-cost-combine"><a href="#3-cost-combine" class="headerlink" title="3.cost combine"></a>3.cost combine</h3><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041833770.png" alt="image-20240804183349742"></p><h3 id="4-SAD-BT"><a href="#4-SAD-BT" class="headerlink" title="4.SAD-BT"></a>4.SAD-BT</h3><p>因为BT代价是一维匹配，所以通常要结合SAD的思路，采用邻域求和的方法，计算SAD-BT，这样计算出来的代价就是局部块代价，每个像素点的匹配代价会包含周围局部区域的信息。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/202408041842891.png" alt="image-20240804184202863"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/21/opencv-shi-yong-ji-qiao/"/>
      <url>/2024/12/21/opencv-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> PixType *row1 = img<span class="number">1.</span><span class="built_in">ptr</span>&lt;PixType&gt;(y), *row2 = img<span class="number">2.</span><span class="built_in">ptr</span>&lt;PixType&gt;(y);</span><br></pre></td></tr></table></figure><ul><li>通过 <code>img1.ptr&lt;PixType&gt;(y)</code> 获取第 <code>y</code> 行的图像数据指针，存储在 <code>row1</code> 中。这个指针指向的是 <code>img1</code> 中第 <code>y</code> 行的所有像素。这种方式是 OpenCV 中常用的方法，可以快速访问图像的特定行数据。</li><li>同样，<code>img2.ptr&lt;PixType&gt;(y)</code> 获取 <code>img2</code> 中第 <code>y</code> 行的指针，存储在 <code>row2</code> 中。</li><li><code>PixType</code> 代表图像中的像素类型（通常为无符号字符 <code>uchar</code>）。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/12/21/dian-cheng-yu-cha-cheng/"/>
      <url>/2024/12/21/dian-cheng-yu-cha-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="点乘与叉乘"><a href="#点乘与叉乘" class="headerlink" title="点乘与叉乘"></a>点乘与叉乘</h1><p>规定向量之间的夹角范围为(0° ≤ θ ≤ 180°)</p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p><strong>点乘</strong>又叫向量的<strong>内积</strong>、<strong>数量积</strong>，&#x3D;&#x3D;是一个向量和它在另一个向量上的投影长度的乘积&#x3D;&#x3D;；几何解释为b向量在a向量方向上的投影乘以a向量模长， 是标量。</p><p>向量的点乘:<code>a * b</code></p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241215151334108.png" alt="image-20241215151334108"></p><p>点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影，公式：<code>a * b = |a| * |b| * cosθ</code></p><p>点乘反映着两个向量的“相似度”，两个向量越“相似”，它们的点乘越大。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241215152249162.png" alt="image-20241215152249162"></p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p><strong>叉乘</strong>，又叫<strong>向量积</strong>、<strong>外积</strong>、<strong>叉积</strong>，叉乘的运算结果是<strong>一个向量</strong>而不是一个标量。并且两个向量的叉积与这两个向量组成的<strong>坐标平面垂直</strong>，且遵守右手定则。</p><p>向量的叉乘：<code>a ∧ b</code></p><p>公式为: <code>a ∧ b = |a| * |b| * sinθ</code></p><p>对于向量a和向量b有:</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241215154114574.png" alt="image-20241215154114574"></p><p>另一种表达为:</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241215154133822.png" alt="image-20241215154133822"></p><p>叉乘的结果向量为垂直a,b两个向量组成平面的向量。</p><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241215154458403.png" alt="image-20241215154458403"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora设置图床</title>
      <link href="/2024/12/21/typora-she-zhi-tu-chuang/"/>
      <url>/2024/12/21/typora-she-zhi-tu-chuang/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora设置图床"><a href="#Typora设置图床" class="headerlink" title="Typora设置图床"></a>Typora设置图床</h1><p>直接使用<code>PicGo.app</code>比较方便，与<code>PicGo-Core</code>存在区别</p><p><strong><code>PicGo.app</code>和<code>PicGo-Core</code>的区别</strong></p><ul><li><code>PicGo.app</code> 提供图形用户界面，而<code>PicGo-Core</code>只有命令行界面</li><li><code>PicGo-Core</code> 上传图片耗费的计算机资源更少，只有在上传图片时进程才会运行，上传结束后(成功或失败)进程都会退出；<code>PicGo.app</code> 会一直保持运行，不会自动退出，而且由于是程序，因此消耗的资源会更多</li></ul><p>本文使用<code>PicGo-Core</code>的设置</p><h2 id="1-修改图像设定"><a href="#1-修改图像设定" class="headerlink" title="1.修改图像设定"></a>1.修改图像设定</h2><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241201171208424.png" alt="image-20241201171208424"></p><h2 id="2-点击下载或更新"><a href="#2-点击下载或更新" class="headerlink" title="2.点击下载或更新"></a>2.点击下载或更新</h2><p>得到配置文件。可能会出现<code>Failed to get latest version of PicGo-Core (command line)</code></p><p>手动使用命令行安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install picgo -g</span><br><span class="line">picgo install github-plus</span><br></pre></td></tr></table></figure><h2 id="3-打开配置文件并修改"><a href="#3-打开配置文件并修改" class="headerlink" title="3.打开配置文件并修改"></a>3.打开配置文件并修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   &quot;picBed&quot;: &#123;</span><br><span class="line">     &quot;current&quot;: &quot;github&quot;, // 代表当前的上传图床</span><br><span class="line">     &quot;uploader&quot;: &quot;github&quot;,</span><br><span class="line">     &quot;github&quot;: &#123;</span><br><span class="line">       &quot;branch&quot;: &quot;master&quot;, // 分支名，默认是 master</span><br><span class="line">       &quot;customUrl&quot;: &quot;&quot;, // 没有自己的域名的话，默认为空即可； 如果自定义域名，注意要加http://或者https://</span><br><span class="line">       &quot;path&quot;: &quot;img/&quot;, // 自定义文件存储路径，比如 img/ 建议填</span><br><span class="line">       &quot;repo&quot;: &quot;&quot;, // 仓库名，格式是 username/reponame &lt;用户名&gt;/&lt;仓库名称&gt; 必填</span><br><span class="line">       &quot;token&quot;: &quot;&quot; // github 私人令牌 必填</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;picgoPlugins&quot;: &#123;</span><br><span class="line">     &quot;picgo-plugin-github-plus&quot;: true  // 启用插件</span><br><span class="line">   &#125; // PicGo插件</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-验证上传结果"><a href="#4-验证上传结果" class="headerlink" title="4.验证上传结果"></a>4.验证上传结果</h2><p><img src="https://raw.githubusercontent.com/SYngsss/CloudImg/master/img/image-20241201172150642.png" alt="image-20241201172150642"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/10/17/hello-world/"/>
      <url>/2024/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
